; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -aggressive-instcombine -S | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define { i64, i64 } @mul_full_64_variant0(i64 %x, i64 %y) {
; CHECK-LABEL: @mul_full_64_variant0(
; CHECK-NEXT:    [[FULLMUL_X:%.*]] = zext i64 [[X:%.*]] to i128
; CHECK-NEXT:    [[FULLMUL_Y:%.*]] = zext i64 [[Y:%.*]] to i128
; CHECK-NEXT:    [[FULLMUL:%.*]] = mul nuw i128 [[FULLMUL_X]], [[FULLMUL_Y]]
; CHECK-NEXT:    [[FULLMUL_LO:%.*]] = trunc i128 [[FULLMUL]] to i64
; CHECK-NEXT:    [[TMP1:%.*]] = lshr i128 [[FULLMUL]], 32
; CHECK-NEXT:    [[FULLMUL_HI:%.*]] = trunc i128 [[TMP1]] to i64
; CHECK-NEXT:    [[RES_LO:%.*]] = insertvalue { i64, i64 } undef, i64 [[FULLMUL_LO]], 0
; CHECK-NEXT:    [[RES:%.*]] = insertvalue { i64, i64 } [[RES_LO]], i64 [[FULLMUL_HI]], 1
; CHECK-NEXT:    ret { i64, i64 } [[RES]]
;
  %xl = and i64 %x, 4294967295
  %xh = lshr i64 %x, 32
  %yl = and i64 %y, 4294967295
  %yh = lshr i64 %y, 32

  %t0 = mul nuw i64 %yl, %xl
  %t1 = mul nuw i64 %yl, %xh
  %t2 = mul nuw i64 %yh, %xl
  %t3 = mul nuw i64 %yh, %xh

  %t0l = and i64 %t0, 4294967295
  %t0h = lshr i64 %t0, 32

  %u0 = add i64 %t0h, %t1
  %u0l = and i64 %u0, 4294967295
  %u0h = lshr i64 %u0, 32

  %u1 = add i64 %u0l, %t2
  %u1ls = shl i64 %u1, 32
  %u1h = lshr i64 %u1, 32

  %u2 = add i64 %u0h, %t3

  %lo = or i64 %u1ls, %t0l
  %hi = add i64 %u2, %u1h

  %res_lo = insertvalue { i64, i64 } undef, i64 %lo, 0
  %res = insertvalue { i64, i64 } %res_lo, i64 %hi, 1
  ret { i64, i64 } %res
}

; The following variants 1 - 3 are generated with this C++ program:
;
; #include <stdint.h>
;
; uint64_t mulxu(uint64_t a, uint64_t b, uint64_t *rhi) {
;     auto hi = [](uint64_t x) { return x >> 32; };
;     auto lo = [](uint64_t x) { return uint32_t(x); };
;     uint64_t xl = lo(a);
;     uint64_t xh = hi(a);
;     uint64_t yl = lo(b);
;     uint64_t yh = hi(b);
;
;     uint64_t rhh = xh * yh;
;     uint64_t rhl = xh * yl;
;     uint64_t rlh = xl * yh;
;     uint64_t rll = xl * yl;
;
;     *rhi = rhh + hi(rhl + hi(rll)) + hi((rlh + lo(rhl + hi(rll))));
; #if ONE
;     return a*b;
; #elif TWO
;     return (uint64_t(lo(rlh + lo(rhl + hi(rll)))) << 32) + lo(rll);
; #elif THREE
;     return ((rlh + rhl) << 32) + rll;
; #endif
; }

define i64 @mul_full_64_variant1(i64 %a, i64 %b, i64* nocapture %rhi) {
; CHECK-LABEL: @mul_full_64_variant1(
; CHECK-NEXT:    [[FULLMUL_A:%.*]] = zext i64 [[A:%.*]] to i128
; CHECK-NEXT:    [[FULLMUL_B:%.*]] = zext i64 [[B:%.*]] to i128
; CHECK-NEXT:    [[FULLMUL:%.*]] = mul nuw i128 [[FULLMUL_A]], [[FULLMUL_B]]
; CHECK-NEXT:    [[FULLMUL_LO:%.*]] = trunc i128 [[FULLMUL]] to i64
; CHECK-NEXT:    [[TMP1:%.*]] = lshr i128 [[FULLMUL]], 32
; CHECK-NEXT:    [[FULLMUL_HI:%.*]] = trunc i128 [[TMP1]] to i64
; CHECK-NEXT:    store i64 [[FULLMUL_HI]], i64* [[RHI:%.*]], align 8
; CHECK-NEXT:    ret i64 [[FULLMUL_LO]]
;
  %conv = and i64 %a, 4294967295
  %shr.i43 = lshr i64 %a, 32
  %conv3 = and i64 %b, 4294967295
  %shr.i41 = lshr i64 %b, 32
  %mul = mul nuw i64 %shr.i41, %shr.i43
  %mul5 = mul nuw i64 %conv3, %shr.i43
  %mul6 = mul nuw i64 %shr.i41, %conv
  %mul7 = mul nuw i64 %conv3, %conv
  %shr.i40 = lshr i64 %mul7, 32
  %add = add i64 %shr.i40, %mul5
  %shr.i39 = lshr i64 %add, 32
  %add10 = add i64 %shr.i39, %mul
  %conv14 = and i64 %add, 4294967295
  %add15 = add i64 %conv14, %mul6
  %shr.i = lshr i64 %add15, 32
  %add17 = add i64 %add10, %shr.i
  store i64 %add17, i64* %rhi, align 8
  %mullo = mul i64 %b, %a
  ret i64 %mullo
}

define i64 @mul_full_64_variant2(i64 %a, i64 %b, i64* nocapture %rhi) {
; CHECK-LABEL: @mul_full_64_variant2(
; CHECK-NEXT:    [[FULLMUL_A:%.*]] = zext i64 [[A:%.*]] to i128
; CHECK-NEXT:    [[FULLMUL_B:%.*]] = zext i64 [[B:%.*]] to i128
; CHECK-NEXT:    [[FULLMUL:%.*]] = mul nuw i128 [[FULLMUL_A]], [[FULLMUL_B]]
; CHECK-NEXT:    [[FULLMUL_LO:%.*]] = trunc i128 [[FULLMUL]] to i64
; CHECK-NEXT:    [[TMP1:%.*]] = lshr i128 [[FULLMUL]], 32
; CHECK-NEXT:    [[FULLMUL_HI:%.*]] = trunc i128 [[TMP1]] to i64
; CHECK-NEXT:    store i64 [[FULLMUL_HI]], i64* [[RHI:%.*]], align 8
; CHECK-NEXT:    ret i64 [[FULLMUL_LO]]
;
  %conv = and i64 %a, 4294967295
  %shr.i58 = lshr i64 %a, 32
  %conv3 = and i64 %b, 4294967295
  %shr.i56 = lshr i64 %b, 32
  %mul = mul nuw i64 %shr.i56, %shr.i58
  %mul5 = mul nuw i64 %conv3, %shr.i58
  %mul6 = mul nuw i64 %shr.i56, %conv
  %mul7 = mul nuw i64 %conv3, %conv
  %shr.i55 = lshr i64 %mul7, 32
  %add = add i64 %shr.i55, %mul5
  %shr.i54 = lshr i64 %add, 32
  %add10 = add i64 %shr.i54, %mul
  %conv14 = and i64 %add, 4294967295
  %add15 = add i64 %conv14, %mul6
  %shr.i51 = lshr i64 %add15, 32
  %add17 = add i64 %add10, %shr.i51
  store i64 %add17, i64* %rhi, align 8
  %conv24 = shl i64 %add15, 32
  %conv26 = and i64 %mul7, 4294967295
  %add27 = or i64 %conv24, %conv26
  ret i64 %add27
}

define i64 @mul_full_64_variant3(i64 %a, i64 %b, i64* nocapture %rhi) {
; CHECK-LABEL: @mul_full_64_variant3(
; CHECK-NEXT:    [[FULLMUL_A:%.*]] = zext i64 [[A:%.*]] to i128
; CHECK-NEXT:    [[FULLMUL_B:%.*]] = zext i64 [[B:%.*]] to i128
; CHECK-NEXT:    [[FULLMUL:%.*]] = mul nuw i128 [[FULLMUL_A]], [[FULLMUL_B]]
; CHECK-NEXT:    [[FULLMUL_LO:%.*]] = trunc i128 [[FULLMUL]] to i64
; CHECK-NEXT:    [[TMP1:%.*]] = lshr i128 [[FULLMUL]], 32
; CHECK-NEXT:    [[FULLMUL_HI:%.*]] = trunc i128 [[TMP1]] to i64
; CHECK-NEXT:    store i64 [[FULLMUL_HI]], i64* [[RHI:%.*]], align 8
; CHECK-NEXT:    ret i64 [[FULLMUL_LO]]
;
  %conv = and i64 %a, 4294967295
  %shr.i45 = lshr i64 %a, 32
  %conv3 = and i64 %b, 4294967295
  %shr.i43 = lshr i64 %b, 32
  %mul = mul nuw i64 %shr.i43, %shr.i45
  %mul5 = mul nuw i64 %conv3, %shr.i45
  %mul6 = mul nuw i64 %shr.i43, %conv
  %mul7 = mul nuw i64 %conv3, %conv
  %shr.i42 = lshr i64 %mul7, 32
  %add = add i64 %shr.i42, %mul5
  %shr.i41 = lshr i64 %add, 32
  %add10 = add i64 %shr.i41, %mul
  %conv14 = and i64 %add, 4294967295
  %add15 = add i64 %conv14, %mul6
  %shr.i = lshr i64 %add15, 32
  %add17 = add i64 %add10, %shr.i
  store i64 %add17, i64* %rhi, align 8
  %add18 = add i64 %mul6, %mul5
  %shl = shl i64 %add18, 32
  %add19 = add i64 %shl, %mul7
  ret i64 %add19
}


define { i32, i32 } @mul_full_32(i32 %x, i32 %y) {
; CHECK-LABEL: @mul_full_32(
; CHECK-NEXT:    [[FULLMUL_X:%.*]] = zext i32 [[X:%.*]] to i64
; CHECK-NEXT:    [[FULLMUL_Y:%.*]] = zext i32 [[Y:%.*]] to i64
; CHECK-NEXT:    [[FULLMUL:%.*]] = mul nuw i64 [[FULLMUL_X]], [[FULLMUL_Y]]
; CHECK-NEXT:    [[FULLMUL_LO:%.*]] = trunc i64 [[FULLMUL]] to i32
; CHECK-NEXT:    [[TMP1:%.*]] = lshr i64 [[FULLMUL]], 16
; CHECK-NEXT:    [[FULLMUL_HI:%.*]] = trunc i64 [[TMP1]] to i32
; CHECK-NEXT:    [[RES_LO:%.*]] = insertvalue { i32, i32 } undef, i32 [[FULLMUL_LO]], 0
; CHECK-NEXT:    [[RES:%.*]] = insertvalue { i32, i32 } [[RES_LO]], i32 [[FULLMUL_HI]], 1
; CHECK-NEXT:    ret { i32, i32 } [[RES]]
;
  %xl = and i32 %x, 65535
  %xh = lshr i32 %x, 16
  %yl = and i32 %y, 65535
  %yh = lshr i32 %y, 16

  %t0 = mul nuw i32 %yl, %xl
  %t1 = mul nuw i32 %yl, %xh
  %t2 = mul nuw i32 %yh, %xl
  %t3 = mul nuw i32 %yh, %xh

  %t0l = and i32 %t0, 65535
  %t0h = lshr i32 %t0, 16

  %u0 = add i32 %t0h, %t1
  %u0l = and i32 %u0, 65535
  %u0h = lshr i32 %u0, 16

  %u1 = add i32 %u0l, %t2
  %u1ls = shl i32 %u1, 16
  %u1h = lshr i32 %u1, 16

  %u2 = add i32 %u0h, %t3

  %lo = or i32 %u1ls, %t0l
  %hi = add i32 %u2, %u1h

  %res_lo = insertvalue { i32, i32 } undef, i32 %lo, 0
  %res = insertvalue { i32, i32 } %res_lo, i32 %hi, 1
  ret { i32, i32 } %res
}


declare i64 @get_number()

; In the following test cases %x and %y are instructions, not arguments.
; This tests the placement of mul i128 and zexts.
; Instructions are also shuffled.

define { i64, i64 } @mul_full_64_variant0_1() {
; CHECK-LABEL: @mul_full_64_variant0_1(
; CHECK-NEXT:    [[TMP1:%.*]] = call i64 @get_number()
; CHECK-NEXT:    [[TMP2:%.*]] = call i64 @get_number()
; CHECK-NEXT:    [[FULLMUL_:%.*]] = zext i64 [[TMP2]] to i128
; CHECK-NEXT:    [[FULLMUL_1:%.*]] = zext i64 [[TMP1]] to i128
; CHECK-NEXT:    [[FULLMUL:%.*]] = mul nuw i128 [[FULLMUL_]], [[FULLMUL_1]]
; CHECK-NEXT:    [[FULLMUL_LO:%.*]] = trunc i128 [[FULLMUL]] to i64
; CHECK-NEXT:    [[TMP3:%.*]] = lshr i128 [[FULLMUL]], 32
; CHECK-NEXT:    [[FULLMUL_HI:%.*]] = trunc i128 [[TMP3]] to i64
; CHECK-NEXT:    [[RES_LO:%.*]] = insertvalue { i64, i64 } undef, i64 [[FULLMUL_LO]], 0
; CHECK-NEXT:    [[RES:%.*]] = insertvalue { i64, i64 } [[RES_LO]], i64 [[FULLMUL_HI]], 1
; CHECK-NEXT:    ret { i64, i64 } [[RES]]
;
  %1 = call i64 @get_number()
  %yl = and i64 %1, 4294967295
  %yh = lshr i64 %1, 32

  %2 = call i64 @get_number()
  %xh = lshr i64 %2, 32
  %xl = and i64 %2, 4294967295

  %t1 = mul nuw i64 %yl, %xh
  %t3 = mul nuw i64 %yh, %xh
  %t2 = mul nuw i64 %yh, %xl
  %t0 = mul nuw i64 %yl, %xl

  %t0h = lshr i64 %t0, 32
  %u0 = add i64 %t0h, %t1
  %u0l = and i64 %u0, 4294967295
  %u1 = add i64 %u0l, %t2
  %u0h = lshr i64 %u0, 32
  %u2 = add i64 %u0h, %t3
  %u1h = lshr i64 %u1, 32
  %hi = add i64 %u2, %u1h

  %u1ls = shl i64 %u1, 32
  %t0l = and i64 %t0, 4294967295
  %lo = or i64 %u1ls, %t0l

  %res_lo = insertvalue { i64, i64 } undef, i64 %lo, 0
  %res = insertvalue { i64, i64 } %res_lo, i64 %hi, 1
  ret { i64, i64 } %res
}

define { i64, i64 } @mul_full_64_variant0_2() {
; CHECK-LABEL: @mul_full_64_variant0_2(
; CHECK-NEXT:    [[X:%.*]] = call i64 @get_number()
; CHECK-NEXT:    [[Y:%.*]] = call i64 @get_number()
; CHECK-NEXT:    [[FULLMUL_X:%.*]] = zext i64 [[X]] to i128
; CHECK-NEXT:    [[FULLMUL_Y:%.*]] = zext i64 [[Y]] to i128
; CHECK-NEXT:    [[FULLMUL:%.*]] = mul nuw i128 [[FULLMUL_X]], [[FULLMUL_Y]]
; CHECK-NEXT:    [[FULLMUL_LO:%.*]] = trunc i128 [[FULLMUL]] to i64
; CHECK-NEXT:    [[TMP1:%.*]] = lshr i128 [[FULLMUL]], 32
; CHECK-NEXT:    [[FULLMUL_HI:%.*]] = trunc i128 [[TMP1]] to i64
; CHECK-NEXT:    [[RES_LO:%.*]] = insertvalue { i64, i64 } undef, i64 [[FULLMUL_LO]], 0
; CHECK-NEXT:    [[RES:%.*]] = insertvalue { i64, i64 } [[RES_LO]], i64 [[FULLMUL_HI]], 1
; CHECK-NEXT:    ret { i64, i64 } [[RES]]
;
  %x = call i64 @get_number()
  %y = call i64 @get_number()

  %yl = and i64 %y, 4294967295
  %yh = lshr i64 %y, 32
  %xh = lshr i64 %x, 32
  %xl = and i64 %x, 4294967295

  %t3 = mul nuw i64 %xh, %yh
  %t2 = mul nuw i64 %xl, %yh
  %t1 = mul nuw i64 %xh, %yl
  %t0 = mul nuw i64 %xl, %yl

  %t0h = lshr i64 %t0, 32
  %u0 = add i64 %t1, %t0h
  %u0l = and i64 %u0, 4294967295
  %u1 = add i64 %t2, %u0l
  %u0h = lshr i64 %u0, 32
  %u2 = add i64 %u0h, %t3
  %u1h = lshr i64 %u1, 32
  %hi = add i64 %u1h, %u2

  %u1ls = shl i64 %u1, 32
  %t0l = and i64 %t0, 4294967295
  %lo = or i64 %t0l, %u1ls

  %res_lo = insertvalue { i64, i64 } undef, i64 %lo, 0
  %res = insertvalue { i64, i64 } %res_lo, i64 %hi, 1
  ret { i64, i64 } %res
}


define i64 @umulh_64(i64 %x, i64 %y) {
; CHECK-LABEL: @umulh_64(
; CHECK-NEXT:    [[FULLMUL_X:%.*]] = zext i64 [[X:%.*]] to i128
; CHECK-NEXT:    [[FULLMUL_Y:%.*]] = zext i64 [[Y:%.*]] to i128
; CHECK-NEXT:    [[FULLMUL:%.*]] = mul nuw i128 [[FULLMUL_X]], [[FULLMUL_Y]]
; CHECK-NEXT:    [[TMP1:%.*]] = lshr i128 [[FULLMUL]], 32
; CHECK-NEXT:    [[FULLMUL_HI:%.*]] = trunc i128 [[TMP1]] to i64
; CHECK-NEXT:    ret i64 [[FULLMUL_HI]]
;
  %xl = and i64 %x, 4294967295
  %xh = lshr i64 %x, 32
  %yl = and i64 %y, 4294967295
  %yh = lshr i64 %y, 32

  %t0 = mul nuw i64 %yl, %xl
  %t1 = mul nuw i64 %yl, %xh
  %t2 = mul nuw i64 %yh, %xl
  %t3 = mul nuw i64 %yh, %xh

  %t0h = lshr i64 %t0, 32

  %u0 = add i64 %t0h, %t1
  %u0l = and i64 %u0, 4294967295
  %u0h = lshr i64 %u0, 32

  %u1 = add i64 %u0l, %t2
  %u1h = lshr i64 %u1, 32

  %u2 = add i64 %u0h, %t3

  %hi = add i64 %u2, %u1h
  ret i64 %hi
}


define i64 @mullo(i64 %x, i64 %y) {
; CHECK-LABEL: @mullo(
; CHECK-NEXT:    [[MUL:%.*]] = mul i64 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    ret i64 [[MUL]]
;
  %xl = and i64 %x, 4294967295
  %xh = lshr i64 %x, 32
  %yl = and i64 %y, 4294967295
  %yh = lshr i64 %y, 32

  %t0 = mul nuw i64 %yl, %xl
  %t1 = mul nuw i64 %yl, %xh
  %t2 = mul nuw i64 %yh, %xl

  %t0l = and i64 %t0, 4294967295
  %t0h = lshr i64 %t0, 32

  %u0 = add i64 %t0h, %t1
  %u0l = and i64 %u0, 4294967295

  %u1 = add i64 %u0l, %t2
  %u1ls = shl i64 %u1, 32

  %lo = or i64 %u1ls, %t0l
  ret i64 %lo
}


declare void @eat_i64(i64)
declare void @eat_i128(i128)

define i64 @mullo_duplicate(i64 %x, i64 %y) {
; CHECK-LABEL: @mullo_duplicate(
; CHECK-NEXT:    [[DUPLICATED_MUL:%.*]] = mul i64 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    call void @eat_i64(i64 [[DUPLICATED_MUL]])
; CHECK-NEXT:    ret i64 [[DUPLICATED_MUL]]
;
  %duplicated_mul = mul i64 %x, %y
  call void @eat_i64(i64 %duplicated_mul)

  %xl = and i64 %x, 4294967295
  %xh = lshr i64 %x, 32
  %yl = and i64 %y, 4294967295
  %yh = lshr i64 %y, 32

  %t0 = mul nuw i64 %yl, %xl
  %t1 = mul nuw i64 %yl, %xh
  %t2 = mul nuw i64 %yh, %xl

  %t0l = and i64 %t0, 4294967295
  %t0h = lshr i64 %t0, 32

  %u0 = add i64 %t0h, %t1
  %u0l = and i64 %u0, 4294967295

  %u1 = add i64 %u0l, %t2
  %u1ls = shl i64 %u1, 32

  %lo = or i64 %u1ls, %t0l
  ret i64 %lo
}

define { i64, i64 } @mul_full_64_duplicate(i64 %x, i64 %y) {
; CHECK-LABEL: @mul_full_64_duplicate(
; CHECK-NEXT:    [[XX:%.*]] = zext i64 [[X:%.*]] to i128
; CHECK-NEXT:    [[YY:%.*]] = zext i64 [[Y:%.*]] to i128
; CHECK-NEXT:    [[DUPLICATED_MUL:%.*]] = mul i128 [[XX]], [[YY]]
; CHECK-NEXT:    call void @eat_i128(i128 [[DUPLICATED_MUL]])
; CHECK-NEXT:    [[FULLMUL_LO:%.*]] = trunc i128 [[DUPLICATED_MUL]] to i64
; CHECK-NEXT:    [[TMP1:%.*]] = lshr i128 [[DUPLICATED_MUL]], 32
; CHECK-NEXT:    [[FULLMUL_HI:%.*]] = trunc i128 [[TMP1]] to i64
; CHECK-NEXT:    [[RES_LO:%.*]] = insertvalue { i64, i64 } undef, i64 [[FULLMUL_LO]], 0
; CHECK-NEXT:    [[RES:%.*]] = insertvalue { i64, i64 } [[RES_LO]], i64 [[FULLMUL_HI]], 1
; CHECK-NEXT:    ret { i64, i64 } [[RES]]
;
  %xx = zext i64 %x to i128
  %yy = zext i64 %y to i128
  %duplicated_mul = mul i128 %xx, %yy
  call void @eat_i128(i128 %duplicated_mul)

  %xl = and i64 %x, 4294967295
  %xh = lshr i64 %x, 32
  %yl = and i64 %y, 4294967295
  %yh = lshr i64 %y, 32

  %t0 = mul nuw i64 %yl, %xl
  %t1 = mul nuw i64 %yl, %xh
  %t2 = mul nuw i64 %yh, %xl
  %t3 = mul nuw i64 %yh, %xh

  %t0l = and i64 %t0, 4294967295
  %t0h = lshr i64 %t0, 32

  %u0 = add i64 %t0h, %t1
  %u0l = and i64 %u0, 4294967295
  %u0h = lshr i64 %u0, 32

  %u1 = add i64 %u0l, %t2
  %u1ls = shl i64 %u1, 32
  %u1h = lshr i64 %u1, 32

  %u2 = add i64 %u0h, %t3

  %lo = or i64 %u1ls, %t0l
  %hi = add i64 %u2, %u1h

  %res_lo = insertvalue { i64, i64 } undef, i64 %lo, 0
  %res = insertvalue { i64, i64 } %res_lo, i64 %hi, 1
  ret { i64, i64 } %res
}
